% Project Plan

\chapter{Project Plan} % Main chapter title

\label{Chapter3} % For referencing the chapter elsewhere, use \ref{Chapter3} 

\lhead{Chapter 3. \emph{Project Plan}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------


In this project, we are attempting to design and develop a rhythm-based computer game where a user's music memory is tested  by presenting him with a sequence of key presses corresponding to different characterisations of the music playing in the background.

So far, we have implemented a skeleton OS X application with a simple user interface, which imports and stores tracks chosen by a user for further analysis. We have also researched some of the available libraries useful for audio processing.

We would like to implement a game where user has an ability to log in and store  (a possibly limited amount of) their levels. The application would also save the scores obtained at each of the levels. User will be able to personalise their account with a name and a picture/avatar, to distinguish themselves from other players using the same computer.

The game requires an implementation of a main melody extraction algorithm. This way we can obtain the melody line which then can be used to generate a level. The details of the algorithm we plan on implementing can be found in section 2.4.2.

The process of the melody extraction will be followed by designing an implementing an algorithm for mapping the melody characteristics to the buttons shown on the screen. Such algorithm could be inspired by the guitar and piano playing techniques. If the next note we encounter has a higher pitch than the one we are currently looking at, the button shown to the user will be the one right of the currently highlighted one. Analogically, if the pitch of the next note is lower, it will activate the button on the right. The gap between the current and the next button will depend on the distance between the two notes analysed. In particular, if the estimated distance is impossible to shown, next button will be allocated in the round robin fashion. For example, in our level we have 5 possible buttons, we are currently looking at the rightmost one and the next one is supposed to be right of the current one, we will highlight the leftmost one. There are further edge cases and subtleties to be considered, which will be described in the Implementation chapter of the final report.

Initially we hoped that the project could train a neural network to produce the buttons. However, it soon became clear that the music analysis section would require a large portion of time to implement, and that there would be insufficient time to design, train and evaluate a neural network system.

Much thought should be given to the implementation of the actual game. In particular, one of the challenges we will be facing is synchronising the visuals of the game, audio track and the reaction of the player. There are two issues to consider here. The most important one is how to make sure we interpret the player's input correctly, so that they feel like they are being rewarded accurately. In addition to this we should make sure that our graphics match the music, so that it looks like the actions are happening in sync with the music.

Potential problems could be caused by the fact that the playhead/position of an audio file tend to update in steps. This is why we will possibly need to interpolate between those steps by keeping track of the playhead position with your own variable, and automatically adding time to that variable every frame. 
In order to take our song time and keep it consistent with the actual playhead position of the audio file, we would like to implement an algorithm to apply corrections every time I get a fresh playhead position

In addition to this, we must take into consideration the delays in the rendering pipelines, as well as the delay that happens between the user hitting a key and the keystroke making it back to the program. In most games, this delay is completely negligible, but as we are implementing a rhythm-based video game, perfect accuracy is a must. That is why a visual delay test must be implemented and ran to calibrate the game before a user starts playing it.

We would also like to implement some additional features to the game to make it more challenging and appealing. Those features could include an accumulator, which would allow the user to gain extra points if they have reacted to the note perfectly. In addition to this, we could make our button generation generate levels of different difficulty, depending on the seed provided by the user. 

\begin{center}
\begin{tabular}{| l | l | p{9cm} |}
\hline
    Index & Week commencing on  & Task  \\ \hline
    1 & 2.02 & Further research of the technologies, libraries.\\ \hline
    2 & 9.02 & Start developing the front end for the game. \\ \hline
    3 & 16.02 & Continue implementing the front end of the game, ask a few people to initially test the look and feel of the game. \\ \hline
    4 & 23.02 & Start implementing the melody detection algorithm -  sinusoid extraction.\\ \hline
    5 & 2.03 & Finish implementing the sinusoid extraction and start to implement the salience function.\\ \hline
    6 & 9.03 & Continue implementing the salience function. Revision for the exams.\\ \hline
    7 & 16.03 & Revision for the exams. \\ \hline
    8 & 23.03 & Exams. \\ \hline
    9 & 30.03 & Implementing pitch contour creation. \\ \hline
    10 & 6.04 & Finish pitch contour creation, implement the melody selection. \\ \hline
    11 & 13.04 & Finish the melody selection, further develop the game to fit the retrieved data on, designing the button mapping algorithm. \\ \hline
    12 & 20.04 & Further work on integration melody into the game, implementing and testing the button mapping algorithm, testing on a small group of users, implementation of the mood detection. \\ \hline
    13 & 27.04 & Work on integration melody into the gameplay, adjusting the game to take the delays into consideration, work on the mood detection. \\ \hline
    14 & 4.05 & Work on the final report. Implementing bonuses, achievements and other user centered features, work on the mood detection. \\ \hline
    15 & 11.05 & Further work on the final report. \\ \hline
    16 & 18.05 & Evaluation and work on the report. \\ \hline
    17 & 25.05 & Evaluation - testing with users filling in questionnaires, writing the final report. \\ \hline
    18 & 8.06 & Polishing up the final report. \\ \hline
    19 & 15.06 & Final Report Due on 16.06 - submission, review and last touches to the code base.\\ \hline
    20 & 22.06 & Preliminary Source Code Archive due on 22.06\\ \hline
    21 & 29.06 & Final Project Archive due on 29.06\\ \hline
    
    \end{tabular}
\end{center}